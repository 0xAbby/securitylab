#include <dirent.h>
#include <string>
#include <functional>

#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)

// Exception class. Caught in main().
class Error : public std::exception {
  std::string msg_;

public:
  explicit Error(const char* msg) : msg_(msg) {}
  explicit Error(std::string&& msg) : msg_(std::move(msg)) {}

  const char* what() const noexcept override {
    return msg_.c_str();
  }
};

// Exception class for system errors that include an errno. Caught in
// main().
class ErrorWithErrno : public Error {
  const int err_;

public:
  explicit ErrorWithErrno(const char* msg) : Error(msg), err_(errno) {}
  explicit ErrorWithErrno(std::string&& msg) : Error(std::move(msg)), err_(errno) {}

  int getErrno() const { return err_; }
};

// This class automatically closes the file descriptor in its destructor.
class AutoCloseFD {
  const int fd_;

  AutoCloseFD() : fd_(-1) {}

public:
  explicit AutoCloseFD(const int fd) : fd_(fd) {}
  ~AutoCloseFD();

  int get() const { return fd_; }
};

// Automatically free a pointer that was malloc'ed.
template <typename T>
class AutoFree {
  T* p_;

public:
  explicit AutoFree(T* p) : p_(p) {}
  ~AutoFree() { free(p_); }

  T* get() const { return p_; }
};

// This class creates an array containing the names of all the files in a
// directory. It does this by running `scandirat` in its constructor.
class ScanDirAt {
  struct dirent **namelist_;
  const int n_;

public:
  explicit ScanDirAt(int fd)
    : n_(scandirat(fd, ".", &namelist_, NULL, alphasort))
  {
    if (n_ < 0) {
      throw ErrorWithErrno("ScanDirAt failed.");
    }
  }

  ~ScanDirAt();

  int size() const { return n_; }

  const char* get(int i) const { return namelist_[i]->d_name; }
};

int create_bind_and_listen_tcp();
uint16_t getportnumber(const int sock);
int add_watch(const int inotify_fd, const char* filename, uint32_t mask);
void createSymlink(const char* target, const int newdirfd, const char* linkname);
int create_file(int dirfd, const char *pathname, mode_t mode);
void write_or_throw(const int fd, const char* buf, size_t buflen);
void create_and_write_file(
  int dirfd, const char *pathname, const char* buf, size_t size, mode_t mode
);
void write_repeated_buffer(
  const int fd, const char* msg, size_t msglen, size_t totallen
);
void fd_wait_for_read(const int inotify_fd);
void drain_fd(const int fd);
void kill_and_wait(const pid_t cpid, const int sig);
pid_t search_pid(const char *cmdline, size_t cmdline_len);
